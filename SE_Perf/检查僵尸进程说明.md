# 检查僵尸进程和进程泄漏指南

## 快速检查方法

### 方法1：使用 Bash 脚本（推荐）
```bash
# 在服务器上运行
bash SE_Perf/check_zombie_processes.sh
```

### 方法2：使用 Python 脚本（更详细）
```bash
# 在服务器上运行
python3 SE_Perf/check_processes.py
```

### 方法3：手动检查命令

#### 检查僵尸进程
```bash
# 查看所有僵尸进程（状态为 Z）
ps aux | awk '$8 ~ /^Z/ { print }'

# 或者更简洁
ps aux | grep -E '^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+Z'
```

#### 检查 perf_run.py 进程
```bash
# 查看所有 perf_run.py 进程
ps aux | grep perf_run.py | grep -v grep

# 统计数量
ps aux | grep perf_run.py | grep -v grep | wc -l
```

#### 检查进程树
```bash
# 找到 instance_runner.py 的 PID
INSTANCE_RUNNER_PID=$(ps aux | grep instance_runner.py | grep -v grep | awk '{print $2}' | head -1)

# 查看进程树
pstree -p $INSTANCE_RUNNER_PID

# 或者使用 ps
ps --ppid $INSTANCE_RUNNER_PID -o pid,cmd
```

#### 检查长时间运行的进程
```bash
# 查看运行时间
ps -eo pid,etime,cmd | grep -E "(instance_runner|perf_run)" | grep -v grep
```

## 常见问题诊断

### 1. 僵尸进程（Zombie Process）
**症状**：进程状态显示为 `Z`

**原因**：
- 子进程已经结束，但父进程还没有调用 `wait()` 或 `waitpid()` 来回收
- 在 `instance_runner.py` 中，如果主进程异常退出，可能导致子进程变成僵尸

**检查**：
```bash
ps aux | awk '$8 ~ /^Z/'
```

**处理**：
- 通常不需要手动处理，僵尸进程不占用资源（除了进程表项）
- 如果父进程还活着，等待父进程清理
- 如果父进程已死，init 进程会接管并清理
- 如果僵尸进程很多且持续存在，可能需要重启系统

### 2. 进程泄漏（Process Leak）
**症状**：`perf_run.py` 进程数量超过预期的并行数（35个）

**原因**：
- 某些任务卡住，没有正常退出
- 主进程异常退出，子进程变成孤儿进程继续运行
- 子进程的子进程没有被正确清理

**检查**：
```bash
# 统计当前运行的 perf_run.py 进程数
ps aux | grep perf_run.py | grep -v grep | wc -l

# 如果超过 35，说明可能有泄漏
```

**处理**：
```bash
# 1. 找到所有 perf_run.py 进程
ps aux | grep perf_run.py | grep -v grep

# 2. 检查是否有进程卡住（运行时间异常长）
ps -eo pid,etime,cmd | grep perf_run.py

# 3. 如果需要，可以手动终止（谨慎操作）
# 找到卡住的进程 PID，然后：
kill -TERM <PID>  # 先尝试优雅终止
# 等待几秒后如果还在运行：
kill -KILL <PID>  # 强制终止
```

### 3. 孤儿进程（Orphan Process）
**症状**：`perf_run.py` 进程的父进程不是 `instance_runner.py`

**检查**：
```bash
# 查看进程的父子关系
ps -eo pid,ppid,cmd | grep -E "(instance_runner|perf_run)" | grep -v grep
```

**处理**：
- 如果主进程已退出，这些孤儿进程会继续运行
- 需要手动终止或等待它们自然结束

## 代码中的潜在问题

### 问题1：`proc.wait()` 没有超时
当前代码中，`proc.wait()` 会无限期等待进程完成。如果进程卡住，会一直等待。

**建议改进**：
```python
# 添加超时机制
import signal

def _run_process_with_timeout(name, cmd, cwd, timeout=3600):  # 默认1小时超时
    # ... 启动进程 ...
    try:
        proc.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        print(f"警告：任务 {name} 超时，正在终止...")
        proc.kill()
        proc.wait()
        return subprocess.CompletedProcess(proc.args, -1)
```

### 问题2：异常退出时子进程清理不完整
如果主进程异常退出（如被 kill -9），子进程可能变成孤儿进程。

**当前代码已有信号处理**，但可以改进：
- 添加更完善的清理机制
- 记录进程 PID 到文件，方便后续清理

### 问题3：子进程的子进程可能泄漏
`perf_run.py` 可能启动自己的子进程，这些进程可能没有被正确清理。

**建议**：
- 在 `perf_run.py` 中也添加信号处理和清理机制
- 使用进程组（`start_new_session=True` 已设置，这是好的）

## 监控建议

### 定期检查脚本
可以设置定时任务定期检查：

```bash
# 添加到 crontab
*/30 * * * * /path/to/check_processes.py >> /tmp/process_check.log 2>&1
```

### 实时监控
```bash
# 每5秒刷新一次进程状态
watch -n 5 'ps aux | grep -E "(instance_runner|perf_run)" | grep -v grep'
```

## 紧急处理流程

如果发现大量僵尸进程或进程泄漏：

1. **记录当前状态**
   ```bash
   ps aux > /tmp/process_snapshot_$(date +%Y%m%d_%H%M%S).txt
   ```

2. **检查主进程是否还在运行**
   ```bash
   ps aux | grep instance_runner.py | grep -v grep
   ```

3. **如果主进程还在运行**
   - 等待一段时间，看是否能自动清理
   - 如果不行，可以发送 SIGTERM 给主进程，让它优雅退出

4. **如果主进程已死**
   - 手动清理孤儿进程
   - 记录哪些任务需要重新运行

5. **清理后验证**
   ```bash
   # 再次检查
   bash SE_Perf/check_zombie_processes.sh
   ```

