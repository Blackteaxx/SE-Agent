<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trajectory Pool Visualization</title>
    <script src="/static/cytoscape.min.js"></script>
    <script src="/static/chart.min.js"></script>
    <script src="/static/chartjs-plugin-datalabels.min.js"></script>
    <script src="/static/dagre.min.js"></script>
    <script src="/static/cytoscape-dagre.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-gray: #ecf0f1;
            --border-color: #bdc3c7;
            --text-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            color: var(--text-color);
            background-color: #fdfdfd;
        }

        #header {
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        #header label {
            margin-right: 15px;
            font-weight: 600;
            font-size: 1.1em;
        }

        #instance-select {
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            font-size: 14px;
            min-width: 300px;
            background-color: white;
            color: var(--text-color);
        }

        #container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #left-panel {
            width: 65%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            position: relative;
        }

        #cy {
            flex: 1;
            background-color: #fafafa;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #chart-container {
            height: 320px;
            padding: 20px;
            background-color: white;
            border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
        }

        #right-panel {
            width: 35%;
            padding: 0;
            overflow-y: auto;
            background-color: #fff;
            box-shadow: -2px 0 5px rgba(0,0,0,0.05);
        }

        #node-details {
            padding: 25px;
        }

        h2 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            font-size: 1.5em;
        }

        h3 {
            color: var(--primary-color);
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        pre {
            white-space: pre-wrap;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: #444;
            overflow-x: auto;
        }

        .info-section {
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
        }

        .info-row {
            display: flex;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .info-label {
            font-weight: 600;
            color: #555;
            width: 120px;
            flex-shrink: 0;
        }

        .info-value {
            color: #333;
            flex: 1;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background-color: var(--secondary-color);
        }
        .splitter-horizontal {
            width: 5px;
            cursor: col-resize;
            background-color: var(--border-color);
            position: relative;
            z-index: 100;
        }

        .splitter-vertical {
            height: 5px;
            cursor: row-resize;
            background-color: var(--border-color);
            position: relative;
            z-index: 100;
        }

        .splitter-horizontal:hover, .splitter-vertical:hover {
            background-color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <div id="header">
        <label for="instance-select">Select Instance:</label>
        <select id="instance-select">
            <option value="">Loading...</option>
        </select>
    </div>
    <div id="container">
        <div id="left-panel">
            <div id="cy"></div>
            <div class="splitter-vertical" id="splitter-vert"></div>
            <div id="chart-container">
                <canvas id="performanceChart"></canvas>
            </div>
        </div>
        <div class="splitter-horizontal" id="splitter-horiz"></div>
        <div id="right-panel">
            <div id="node-details">
                <h2>Node Details</h2>
                <p>Click on a node to view details here.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Splitter Logic
            const container = document.getElementById('container');
            const leftPanel = document.getElementById('left-panel');
            const rightPanel = document.getElementById('right-panel');
            const chartContainer = document.getElementById('chart-container');
            const cyContainer = document.getElementById('cy');
            const splitterHoriz = document.getElementById('splitter-horiz');
            const splitterVert = document.getElementById('splitter-vert');

            // Horizontal Splitter (Left vs Right)
            let isResizingHoriz = false;
            splitterHoriz.addEventListener('mousedown', function(e) {
                isResizingHoriz = true;
                document.body.style.cursor = 'col-resize';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizingHoriz) return;
                
                const containerRect = container.getBoundingClientRect();
                const newLeftWidth = e.clientX - containerRect.left;
                
                // Min/Max constraints
                if (newLeftWidth > 200 && newLeftWidth < containerRect.width - 200) {
                    const percentage = (newLeftWidth / containerRect.width) * 100;
                    leftPanel.style.width = `${percentage}%`;
                    rightPanel.style.width = `${100 - percentage}%`;
                    if (cy) cy.resize(); // Resize Cytoscape
                    if (chart) chart.resize(); // Resize Chart
                }
            });

            // Vertical Splitter (Graph vs Chart)
            let isResizingVert = false;
            splitterVert.addEventListener('mousedown', function(e) {
                isResizingVert = true;
                document.body.style.cursor = 'row-resize';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizingVert) return;

                const leftPanelRect = leftPanel.getBoundingClientRect();
                // Calculate height relative to the left panel
                const newCyHeight = e.clientY - leftPanelRect.top - 50; // 50 offset for header roughly? No, clientY is global.
                // Actually leftPanelRect.top is header bottom.
                
                const relativeY = e.clientY - leftPanelRect.top;
                
                // Constraints
                if (relativeY > 100 && relativeY < leftPanelRect.height - 100) {
                     // We set flex basis or height. 
                     // Since left-panel is flex column, we can set height of cy and let chart take rest, or vice versa.
                     // Currently #cy has flex: 1. #chart-container has fixed height.
                     // Let's change this structure slightly in CSS/JS logic.
                     
                     // Better approach: Set height of chart-container, and let cy take the rest (flex: 1).
                     // chart-container height = total height - relativeY
                     const newChartHeight = leftPanelRect.height - relativeY;
                     chartContainer.style.height = `${newChartHeight}px`;
                     chartContainer.style.flex = 'none';
                     cyContainer.style.flex = '1';
                     
                     if (cy) cy.resize();
                     if (chart) chart.resize();
                }
            });

            document.addEventListener('mouseup', function() {
                isResizingHoriz = false;
                isResizingVert = false;
                document.body.style.cursor = 'default';
            });

            let cy = null;
            let chart = null;
            let rawData = null;

            // Initialize Chart.js
            const ctx = document.getElementById('performanceChart').getContext('2d');

            // Fetch data
            fetch('/api/data')
                .then(response => {
                    console.log('Fetch response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data);
                    
                    // Register dagre extension
                    if (typeof cytoscapeDagre !== 'undefined') {
                        cytoscape.use(cytoscapeDagre);
                    } else if (typeof dagre !== 'undefined' && cytoscape) {
                        // Try auto-registration or check if already registered
                        // Sometimes it's auto-registered if included after cytoscape
                    }

                    rawData = data;
                    populateInstanceSelect(data);
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('node-details').innerHTML = `<h2>Error</h2><p>${error.message}</p>`;
                });

            function populateInstanceSelect(data) {
                console.log('Populating select with keys:', Object.keys(data));
                const select = document.getElementById('instance-select');
                select.innerHTML = '';
                
                // Sort keys for consistent order
                const keys = Object.keys(data).sort();
                
                if (keys.length > 0) {
                    keys.forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        select.appendChild(option);
                    });
                    
                    // Select first instance by default
                    select.value = keys[0];
                    console.log('Auto-selecting first instance:', keys[0]);
                    renderInstance(keys[0]);
                } else {
                    console.warn('No keys found in data');
                    select.innerHTML = '<option>No data available</option>';
                }

                select.addEventListener('change', function() {
                    console.log('Instance changed to:', this.value);
                    renderInstance(this.value);
                });
            }

            function renderInstance(instanceKey) {
                console.log('Rendering instance:', instanceKey);
                const instanceData = rawData[instanceKey];
                if (!instanceData) {
                    console.error('No data found for instance:', instanceKey);
                    return;
                }

                try {
                    renderGraph(instanceData);
                    renderChart(instanceData);
                } catch (e) {
                    console.error('Error rendering instance:', e);
                }
                
                // Clear details panel but keep header
                // document.getElementById('node-details').innerHTML = '<h2>Node Details</h2><p>Click on a node to view details here.</p>';
                
                // Show problem description
                const problemDesc = instanceData['problem'] || 'No problem description available.';
                displayProblemDescription(problemDesc);
            }

            function displayProblemDescription(desc) {
                const container = document.getElementById('node-details');
                container.innerHTML = `
                    <div class="info-section" style="background-color: #f8f9fa; border-left: 4px solid #2c3e50; padding: 15px; margin-bottom: 25px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h3 style="margin-top: 0; border-bottom: 1px solid #e9ecef; padding-bottom: 10px; margin-bottom: 15px; color: #2c3e50;">Problem Description</h3>
                        <div style="max-height: 400px; overflow-y: auto; font-family: 'Segoe UI', sans-serif; line-height: 1.6; color: #333; white-space: pre-wrap; font-size: 14px;">${desc}</div>
                    </div>
                    <h2>Node Details</h2>
                    <p id="default-msg">Click on a node to view details here.</p>
                `;
            }

            function renderGraph(instanceData) {
                console.log('Rendering graph for data:', instanceData);
                const elements = [];
                const nodes = [];
                const edges = [];
                const solutions = [];
                
                // Step 1: Identify all valid solutions and create nodes first
                // Also collect iterations to create parent compound nodes
                const iterations = new Set();

                Object.keys(instanceData).forEach(key => {
                    if (key === 'problem') return;
                    const solution = instanceData[key];
                    if (typeof solution !== 'object') return;
                    
                    solutions.push({ key, solution });
                    
                    // Create node logic
                    let nodeColor = '#3498db'; // Default blue
                    let labelText = solution.label || key;
                    
                    // Determine iteration for grouping based on label ONLY
                    // Format: iterX_...
                    let iter = undefined;
                    if (labelText && labelText.startsWith('iter')) {
                        const match = labelText.match(/^iter(\d+)_/);
                        if (match) {
                            iter = parseInt(match[1]);
                        }
                    }
                    
                    const parentId = iter !== undefined ? `iteration_${iter}` : 'iteration_unknown';
                    iterations.add(parentId);

                        // Determine color based on status or metrics if available
                        // User Requirement 3: sol 的颜色需要代表是否通过， `/data/CodeEfficiency/SE-Agent/trajectories_perf/deepseek/deepseek-v3.1-test-example_20251203_120416/traj.pool#L172-173` 可以用这个来判断
                        
                        if (solution.perf_metrics) {
                            if (solution.perf_metrics.passed === true) {
                                nodeColor = '#2ecc71'; // Green for success
                            } else if (solution.perf_metrics.passed === false) {
                                nodeColor = '#e74c3c'; // Red for failure
                            } else {
                                // Fallback or unknown status
                                nodeColor = '#f39c12'; // Orange
                            }
                        } else if (solution.summary && solution.summary.metrics) {
                            // Old fallback
                            const metrics = solution.summary.metrics;
                            if (metrics.includes("Pass rate: 100.00%")) {
                                nodeColor = '#2ecc71'; // Green for success
                            } else if (metrics.includes("Pass rate: 0.00%") || metrics.includes("Failed") || metrics.includes("Error")) {
                                nodeColor = '#e74c3c'; // Red for failure
                            } else if (metrics.includes("Pass rate:")) {
                                nodeColor = '#f39c12'; // Orange for partial/mixed
                            }
                        }

                    nodes.push({
                        data: { 
                            id: key, 
                            label: labelText,
                            parent: parentId, // Assign to compound node
                            info: solution
                        },
                        style: {
                            'background-color': nodeColor
                        }
                    });
                });

                // Add compound nodes for iterations
                Array.from(iterations).sort().forEach(iterId => {
                    nodes.push({
                        data: { id: iterId, label: iterId.replace('iteration_', 'Iteration ').replace('unknown', 'Unknown') },
                        classes: 'compound-node'
                    });
                });

                // Step 2: Create edges after all known nodes are created
                solutions.forEach(({ key, solution }) => {
                    
                    // Create edges based on source_entry_labels
                    // User requested strictly use root level source_entry_labels ONLY. 
                    // Do NOT fallback to summary.source_entry_labels as it is unreliable.
                    let sourceLabels = [];
                    if (solution.source_entry_labels) {
                        sourceLabels = solution.source_entry_labels;
                    }

                    sourceLabels.forEach(sourceLabel => {
                        if (!sourceLabel || sourceLabel.trim() === '') return;

                        // Check if source node exists in our created nodes
                        const sourceExists = nodes.some(n => n.data.id === sourceLabel);
                        
                        if (!sourceExists) {
                            // Only create ghost node if it really doesn't exist in the data we processed
                            // (and hasn't been created as a ghost yet)
                             const ghostExists = nodes.some(n => n.data.id === sourceLabel); // Check again just in case
                             if (!ghostExists) {
                                nodes.push({
                                    data: { 
                                        id: sourceLabel, 
                                        label: sourceLabel + ' (External)',
                                        info: { label: sourceLabel, summary: { solution_name: 'Unknown' } }
                                    },
                                    style: { 'background-color': '#ccc' }
                                });
                             }
                        }

                        edges.push({
                            data: {
                                    source: sourceLabel,
                                    target: key,
                                    label: solution.operator_name || ''
                                }
                        });
                    });
                });

                if (cy) {
                    cy.destroy();
                }

                cy = cytoscape({
                    container: document.getElementById('cy'),
                    elements: [...nodes, ...edges],
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-color': '#3498db',
                                'label': 'data(label)',
                                'color': '#fff',
                                'text-valign': 'center',
                                'text-halign': 'center',
                                'font-size': '12px',
                                'font-weight': 'bold',
                                'width': '120px',
                                'height': '50px',
                                'shape': 'round-rectangle',
                                'text-wrap': 'wrap',
                                'text-max-width': '110px',
                                'border-width': 2,
                                'border-color': '#fff',
                                'shadow-blur': 3,
                                'shadow-color': '#ccc',
                                'shadow-opacity': 0.5
                            }
                        },
                        {
                            selector: 'edge',
                            style: {
                                'width': 2,
                                'line-color': '#bdc3c7',
                                'target-arrow-color': '#bdc3c7',
                                'target-arrow-shape': 'triangle',
                                'curve-style': 'bezier',
                                'arrow-scale': 1.2,
                                'label': 'data(label)',
                                'text-rotation': 'autorotate',
                                'text-background-color': '#fff',
                                'text-background-opacity': 0.8,
                                'text-background-padding': '2px',
                                'font-size': '10px',
                                'color': '#555'
                            }
                        },
                        {
                            selector: ':selected',
                            style: {
                                'border-width': 3,
                                'border-color': '#2c3e50',
                                'shadow-blur': 10,
                                'shadow-color': '#2c3e50',
                                'shadow-opacity': 0.3
                            }
                        },
                        {
                            selector: '.compound-node',
                            style: {
                                'background-color': '#f9f9f9',
                                'background-opacity': 0.5,
                                'border-width': 1,
                                'border-color': '#ccc',
                                'border-style': 'dashed',
                                'label': 'data(label)',
                                'text-valign': 'top',
                                'text-halign': 'center',
                                'font-size': '16px',
                                'font-weight': 'bold',
                                'color': '#7f8c8d',
                                'padding': '10px'
                            }
                        }
                    ],
                    layout: {
                        name: 'dagre',
                        rankDir: 'LR',
                        nodeDimensionsIncludeLabels: true,
                        spacingFactor: 1.2,
                        rankSep: 100, // Separation between ranks (iterations likely fall into ranks)
                        nodeSep: 50   // Separation between nodes in same rank
                    }
                });

                cy.on('tap', 'node', function(evt){
                    const node = evt.target;
                    displayNodeDetails(node.data('info'));
                });
            }

            function displayNodeDetails(info) {
                // We don't want to overwrite the problem description
                // So we should append or replace only the node details part
                // Or easier: just re-render everything in the right panel properly
                // But wait, we should keep problem description at the top?
                
                const container = document.getElementById('node-details');
                
                // Check if problem description exists, save it
                let problemHtml = '';
                const existingProblem = container.querySelector('.info-section h3');
                if (existingProblem && existingProblem.textContent === 'Problem Description') {
                    problemHtml = container.querySelector('.info-section').outerHTML;
                }
                
                let html = problemHtml; // Start with problem description
                html += `<h2>${info.label || 'Node Details'}</h2>`;
                
                // Helper to recursively display object
                function formatValue(val) {
                    if (typeof val === 'object' && val !== null) {
                        return '<pre>' + JSON.stringify(val, null, 2) + '</pre>';
                    }
                    return val;
                }

                // Display specific fields first if they exist
                if (info.iteration !== undefined) {
                    html += `<div class="info-section"><span class="info-label">Iteration:</span> ${info.iteration}</div>`;
                }
                if (info.performance !== undefined) {
                    html += `<div class="info-section"><span class="info-label">Performance:</span> ${info.performance}</div>`;
                }
                
                if (info.summary) {
                    html += `<div class="info-section"><h3>Summary</h3>`;
                    
                    if (info.summary.solution_name) {
                        html += `<div><span class="info-label">Solution Name:</span> ${info.summary.solution_name}</div>`;
                    }
                    
                    if (info.summary.approach_summary) {
                        html += `<div><span class="info-label">Approach:</span> <p>${info.summary.approach_summary}</p></div>`;
                    }

                    // Improved Summary Display
                    // We want to show the entire summary object nicely formatted if needed, 
                    // or at least specific fields like slot_view if they exist.
                    // For now, let's just format the whole summary object excluding what we already showed.
                    // Actually, the user asked to "display summary on the right side, nicely formatted".
                    // Let's create a collapsible or scrollable pre block for the full summary JSON
                    // or a better structured view.
                    
                    html += `<div style="margin-top: 10px;">
                        <h4 style="margin: 5px 0; color: #555;">Full Summary Details</h4>
                        <pre style="max-height: 300px; overflow: auto; font-size: 12px;">${JSON.stringify(info.summary, null, 2)}</pre>
                    </div>`;

                    html += `</div>`;
                }

                // 2. Extract last assistant message from trajectory_raw
                if (info.trajectory_raw && info.trajectory_raw.Trajectory) {
                    const traj = info.trajectory_raw.Trajectory;
                    let lastAssistantMsg = null;
                    
                    // Iterate backwards to find the last assistant message
                    for (let i = traj.length - 1; i >= 0; i--) {
                        if (traj[i].role === 'assistant') {
                            lastAssistantMsg = traj[i].content;
                            break;
                        }
                    }

                    if (lastAssistantMsg) {
                        html += `<div class="info-section">
                            <h3>Last Assistant Message</h3>
                            <div style="white-space: pre-wrap; background: #f4f6f7; padding: 15px; border-radius: 5px; border-left: 4px solid #3498db; font-family: 'Segoe UI', monospace; font-size: 13px; max-height: 500px; overflow-y: auto;">${lastAssistantMsg}</div>
                        </div>`;
                    }
                }


                if (info.code) {
                     html += `<div class="info-section"><h3>Code</h3><pre>${info.code}</pre></div>`;
                }

                // Generic dump of other fields
                html += `<div class="info-section"><h3>Full Data</h3><pre>${JSON.stringify(info, null, 2)}</pre></div>`;

                container.innerHTML = html;
            }

            function renderChart(instanceData) {
                // Extract all solutions
                const allSolutions = [];
                
                Object.keys(instanceData).forEach(key => {
                    if (key === 'problem') return;
                    const solution = instanceData[key];
                    
                    let iter = solution.iteration;
                    let perf = solution.performance;
                    let label = solution.label || key;

                    // Try to find iteration in evolution_steps if missing
                    if (iter === undefined && solution.summary && solution.summary.evolution_steps) {
                         const steps = solution.summary.evolution_steps;
                         if (steps.length > 0) {
                             iter = steps[steps.length - 1].iteration;
                         }
                    }

                    if (iter !== undefined) {
                        // Handle performance
                        let val = Infinity;
                        if (perf !== undefined && perf !== "Infinity") {
                             if (typeof perf === 'string') {
                                 val = parseFloat(perf);
                             } else {
                                 val = perf;
                             }
                             if (isNaN(val)) val = Infinity;
                        }
                        
                        // Add to all solutions list if we have valid iteration
                        if (val !== Infinity) {
                            allSolutions.push({
                                x: parseInt(iter),
                                y: val,
                                label: label,
                                solutionKey: key,
                                info: solution
                            });
                        }
                    }
                });

                // Calculate Best Performance Line (Pareto Frontier for Min Performance)
                // We need to find the minimum performance up to each iteration
                // Group by iteration first to find best per iteration
                const bestPerIter = {};
                allSolutions.forEach(sol => {
                    if (!bestPerIter[sol.x] || sol.y < bestPerIter[sol.x].y) {
                        bestPerIter[sol.x] = sol;
                    }
                });

                // Create sorted iterations list
                const sortedIters = Object.keys(bestPerIter).map(i => parseInt(i)).sort((a, b) => a - b);
                
                // Propagate best performance forward
                const bestLineData = [];
                if (sortedIters.length > 0) {
                    let currentBest = bestPerIter[sortedIters[0]].y;
                    let currentBestLabel = bestPerIter[sortedIters[0]].label;
                    
                    // Add first point
                    bestLineData.push({
                        x: sortedIters[0],
                        y: currentBest,
                        label: currentBestLabel,
                        isTurningPoint: true
                    });

                    for (let i = 1; i < sortedIters.length; i++) {
                        const iter = sortedIters[i];
                        const iterBest = bestPerIter[iter];
                        
                        if (iterBest.y < currentBest) {
                            // Improvement found
                            currentBest = iterBest.y;
                            currentBestLabel = iterBest.label;
                            bestLineData.push({
                                x: iter,
                                y: currentBest,
                                label: currentBestLabel,
                                isTurningPoint: true
                            });
                        } else {
                            // No improvement.
                            // User wants: "Pareto front doesn't need points everywhere, only connect turning points"
                            // So we do NOT add a point here if it's just a flat line extension.
                            // The line chart will automatically connect the previous turning point to the next one.
                        }
                    }
                    
                    // However, if the last point wasn't a turning point, we might want to extend the line to the end?
                    // Or just let it end at the last turning point?
                    // "Pareto front" usually implies the best found SO FAR.
                    // If we skip intermediate points, the line will just connect turning points directly.
                    // This matches "connect turning points directly".
                }

                if (chart) {
                    chart.destroy();
                }
                
                // Register plugin explicitly
                if (typeof ChartDataLabels !== 'undefined') {
                    Chart.register(ChartDataLabels);
                }

                chart = new Chart(ctx, {
                    type: 'scatter',
                    // Remove local plugins array if registered globally, or keep if specific
                    // plugins: [ChartDataLabels], 
                    data: {
                        datasets: [
                            {
                                label: 'All Solutions',
                                data: allSolutions,
                                backgroundColor: 'rgba(100, 100, 100, 0.6)',
                                borderColor: 'rgba(100, 100, 100, 0.8)',
                                pointRadius: 4,
                                pointHoverRadius: 6,
                                order: 2, // Draw behind line
                                datalabels: {
                                    display: false // Hide labels for scatter points
                                }
                            },
                            {
                                type: 'line',
                                label: 'Pareto Frontier (Best Perf)',
                                data: bestLineData,
                                borderColor: '#e74c3c', // Red line like user example
                                backgroundColor: 'rgba(231, 76, 60, 0.05)',
                                borderWidth: 3,
                                pointBackgroundColor: '#e74c3c',
                                pointBorderColor: '#fff',
                                pointRadius: 6, // Highlight turning points
                                pointHoverRadius: 8,
                                tension: 0,
                                fill: false,
                                order: 1, // Draw on top
                                datalabels: {
                                    align: function(context) {
                                        // Alternate label positions to reduce overlap
                                        // Or base it on slope? For simplicity, alternate top/bottom or just push further away
                                        return context.dataIndex % 2 === 0 ? 'top' : 'bottom';
                                    },
                                    anchor: function(context) {
                                        return context.dataIndex % 2 === 0 ? 'start' : 'end';
                                    },
                                    offset: function(context) {
                                        // Stagger distance
                                        return context.dataIndex % 2 === 0 ? 20 : 20;
                                    },
                                    backgroundColor: '#fdfea3', 
                                    color: '#333',
                                    borderColor: '#333',
                                    borderWidth: 1,
                                    borderRadius: 4,
                                    font: {
                                        weight: 'bold',
                                        size: 11
                                    },
                                    padding: 6,
                                    formatter: function(value, context) {
                                        return value.label;
                                    },
                                    display: function(context) {
                                        return context.dataset.data[context.dataIndex].isTurningPoint;
                                    }
                                }
                            }
                        ]
                    },
                    plugins: [{
                        id: 'connectorLines',
                        afterDatasetsDraw: (chart, args, options) => {
                            const ctx = chart.ctx;
                            const dataset = chart.data.datasets[1]; // The Pareto line dataset
                            const meta = chart.getDatasetMeta(1);
                            
                            ctx.save();
                            ctx.beginPath();
                            ctx.strokeStyle = '#555';
                            ctx.lineWidth = 1;
                            
                            dataset.data.forEach((dataPoint, index) => {
                                if (dataPoint.isTurningPoint) {
                                    const element = meta.data[index];
                                    if (!element) return;
                                    
                                    const { x, y } = element.tooltipPosition();
                                    const isTop = index % 2 === 0;
                                    const offset = 20;
                                    
                                    // Draw line from point to label
                                    ctx.moveTo(x, y);
                                    if (isTop) {
                                        ctx.lineTo(x, y - offset);
                                    } else {
                                        ctx.lineTo(x, y + offset);
                                    }
                                    ctx.stroke();
                                    
                                    // Small dot at the end
                                    ctx.beginPath();
                                    if (isTop) {
                                         ctx.arc(x, y - offset, 2, 0, 2 * Math.PI);
                                    } else {
                                         ctx.arc(x, y + offset, 2, 0, 2 * Math.PI);
                                    }
                                    ctx.fillStyle = '#555';
                                    ctx.fill();
                                }
                            });
                            ctx.restore();
                        }
                    }],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (e, elements) => {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const datasetIndex = element.datasetIndex;
                                const index = element.index;
                                const dataPoint = chart.data.datasets[datasetIndex].data[index];
                                
                                if (dataPoint.solutionKey) {
                                    // It's a scatter point with direct solution link
                                    displayNodeDetails(dataPoint.info);
                                    // Also select in Cytoscape if possible
                                    if (cy) {
                                        cy.$(':selected').unselect();
                                        cy.$id(dataPoint.solutionKey).select();
                                    }
                                } else if (datasetIndex === 1) {
                                    // It's a line point. We need to find the matching solution.
                                    const match = allSolutions.find(s => s.x === dataPoint.x && s.y === dataPoint.y);
                                    if (match) {
                                        displayNodeDetails(match.info);
                                        if (cy) {
                                            cy.$(':selected').unselect();
                                            cy.$id(match.solutionKey).select();
                                        }
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Performance Analysis (Pareto Frontier)',
                                font: { size: 16, family: "'Segoe UI', sans-serif" },
                                padding: 20
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        return `${point.label}: ${point.y.toFixed(4)}s (Iter ${point.x})`;
                                    }
                                }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { usePointStyle: true, padding: 20 }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: { display: true, text: 'Iteration', font: { weight: 'bold' } }
                            },
                            y: {
                                title: { display: true, text: 'Performance (Runtime)', font: { weight: 'bold' } }
                            }
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>
